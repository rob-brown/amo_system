# Squad Strike Runner

```elixir
Mix.install([
  {:squad_strike, path: Path.join([__DIR__, "rabbit_driver", "squad_strike"])},
  {:jason, "~> 1.4"},
  {:amqp, "~> 3.3"},
  {:kino, "~> 0.10.0"}
])
```

## Setup RabbitMQ

**Before Running This Livbook!**

You first, need to open the Secrets tab in the sidebar to the left. In there you need to create
a secret named `AMQP_URL`. You will then put in the URL to connect to your RabbitMQ broker. It
will look like this:

```
amqp://username:password@raspberrypi.local:5672
```

If you enter it wrong, then you may see an error like this when running the setup cell.

```

01:12:17.379 [info] Application squad_strike exited: SquadStrike.Application.start(:normal, []) returned an error: shutdown: failed to start child: SquadStrike.MQ
    ** (EXIT) an exception was raised:
        ** (MatchError) no match of right hand side value: {:error, :econnrefused}
            (squad_strike 0.1.0) lib/squad_strike/mq.ex:22: anonymous fn/2 in SquadStrike.MQ.start_link/1
            (elixir 1.14.2) lib/agent/server.ex:8: Agent.Server.init/1
            (stdlib 4.0.1) gen_server.erl:848: :gen_server.init_it/2
            (stdlib 4.0.1) gen_server.erl:811: :gen_server.init_it/6
            (stdlib 4.0.1) proc_lib.erl:240: :proc_lib.init_p_do_apply/3
```

The default domain for a Raspberry Pi is `raspberrypi.local`. However, if you changed it, then
you will need to update the AMQP URL as well.

<!-- livebook:{"branch_parent_index":0} -->

## Logs

The app will send out logs, which you can watch. Once run, this will print logs to the must
recently run cell. Stopping this cell will stop the logs from appearing.

<blockquote style="background-color:#F5FF7B; color:black">
ðŸ’¡ This section runs in parallel with other code. That way you can watch the 
logs while running something else. You can skip over this section if you don't need it. 
</blockquote>

```elixir
require Logger

url = SquadStrike.MQ.url()
exchange = SquadStrike.MQ.exchange()

{:ok, conn} = AMQP.Connection.open(url)
{:ok, channel} = AMQP.Channel.open(conn)
{:ok, %{queue: queue}} = AMQP.Queue.declare(channel, "", exclusive: true, auto_delete: true)

pid =
  spawn(fn ->
    AMQP.Queue.bind(channel, queue, exchange, routing_key: "log.#")
    {:ok, tag} = AMQP.Basic.consume(channel, queue, nil, no_ack: true)

    handler = fn recurse ->
      receive do
        {:basic_cancel, _meta} ->
          :ok

        {:basic_deliver, payload, _meta} ->
          %{"level" => level, "msg" => msg, "timestamp" => time} = Jason.decode!(payload)

          IO.puts("#{time} [#{level}] #{inspect(msg)}")

          recurse.(recurse)

        _ ->
          recurse.(recurse)
      after
        # When pings stop, automatically unsubscribe.
        2000 ->
          AMQP.Queue.unsubscribe(channel, tag)
          :ok
      end
    end

    handler.(handler)
  end)

heart_beat = fn recurse ->
  # Send the log watcher a ping to keep it alive.
  send(pid, :ping)

  # Wait a second so we aren't spamming the process.
  Process.sleep(1000)

  recurse.(recurse)
end

# Run the heartbeat function until the cell is explicitly stopped.
# Stopping the hearbeat messages will cause the queue to be cleaned up.
heart_beat.(heart_beat)
```

<!-- livebook:{"branch_parent_index":0} -->

## Screenshot

This section has some cells that are useful for debugging your capture card. Or you can use this
to get screenshots that you can then modify for use as targets in your automation.

<blockquote style="background-color:#F5FF7B; color:black">
ðŸ’¡ This section runs in parallel with other code. That way you can watch the 
continuous screen capture while running something else. You can skip over this section if you
don't need it. </blockquote>

First, is some basic code to handle requesting and handling the image. 
</blockquote>

```elixir
defmodule Screenshot do
  def capture(fun, opts \\ []) do
    {:ok, json, _meta} = SquadStrike.MQ.call("image.screenshot", %{timeout_ms: 1000}, opts)

    bytes = Base.decode64!(json["screenshot"]["bytes"])

    fun.(bytes)
  rescue
    _error ->
      nil
  end

  def capture_forever(delay, fun) do
    # Create a queue so we don't make a new one with each request.
    channel = SquadStrike.MQ.channel()
    {:ok, %{queue: queue}} = AMQP.Queue.declare(channel, "", exclusive: true, auto_delete: true)

    capture(fun, reply_to: queue)
    Process.sleep(delay)
    capture_forever(delay, fun)
  end
end
```

The next cell will capture a single image and display it. It's most useful for when grabbing an
image to use as an automation target. If the full image doesn't appear completely, then run the
cell again.

You will notice the screenshot appears squished. This is because the capture card is using a 
resolution of 640x480 which is a 4x3 ratio. The Switch normally runs a 16x9 ratio. This is 
expected and not a problem.

```elixir
image =
  Screenshot.capture(fn bytes ->
    bytes
  end)
```

```elixir
bytes = image |> Base.encode64()
data_url = "data:image/png;base64,#{bytes}"

cast.("image.put", %{name: "homescreen.png", bytes: data_url})
```

```elixir
call.("image.list", %{})
```

```elixir
call.("image.visible", %{name: "homescreen.png"})
```

This next cell will continuously capture images every few seconds. You can change the capture
rate. It's a number in milliseconds. Or you can use the `:timer.seconds` function. Be sure to 
click the <strong>Stop</strong> button when you are done watching.

```elixir
frame = Kino.Frame.new() |> Kino.render()

Screenshot.capture_forever(channel, exchange, :timer.seconds(5), fn bytes ->
  Kino.Frame.render(frame, bytes)
end)
```

## Scripting

```elixir
script = """
for i = 0,10,1
do
  press("left", 200)
  press("left", 200)
  press("right", 200)
  press("right", 200)
end
"""

call_with_opts.("script.run", %{raw: script, timeout_ms: 20_000}, timeout_ms: 20_000)
```

```elixir
script = """
press("right", 200)
press("a", "1s")
press("b")
"""

cast.("script.put", %{name: "test.lua", bytes: Base.encode64(script)})
```

```elixir
call.("script.list", %{})
```

```elixir
call.("script.list", %{name: "test.lua"})
```

```elixir
call_with_opts.("script.run", %{name: "test.lua", timeout_ms: 5000}, timeout_ms: 5000)
```

<!-- livebook:{"branch_parent_index":0} -->

## Squad Strike Automation

To run the automation, we first send some target images that we want to look for. They are 
usually small, unambiguous parts fo the screen.

![](img/ready_to_fight.png)

The scripts will reference these images. Typically checking if the image is visible, waiting until it becomes visible, or waiting until it disappears.

These images are dependent on the screen resolution of the capture card. If you don't use 
**640x480** as your resolution, then you must update all the images accordingly.

```elixir
images = ~w[kirby.png pointer.png ready_to_fight.png]
dir = Path.join(__DIR__, "img")

for img <- images do
  bytes = img |> Path.expand(dir) |> File.read!() |> Base.encode64()
  data_url = "data:image/png;base64,#{bytes}"

  cast.("image.put", %{name: img, bytes: data_url})
end
```

You can then check that the images were uploaded. Other images may also be present.

```elixir
call.("image.list", %{})
```

The automations also need the scripts. The scripts can be sent and run in the same message. Though for scripts that are run frequently, we can save some time but sending them upfront and then referencing them later.

The scripts are written in Lua. This is an embedded programming language that is able to safely call into the original Elixir code without recompiling.

```elixir
scripts = %{
  launch_ssbu_to_squad_strike: """
  -- Focus on first game.
  -- Assumes this is the desired game.
  press("home")
  wait("1500ms")
  -- Open game
  press("a")
  wait("2s")
  -- Select first player account.
  press("a", "500ms")
  -- Wait a long time for game to launch.
  wait_until_found("kirby.png", "40s")
  -- Skip intro video to title screen.
  press("a")
  wait("2s")
  -- Advance to game menu.
  press("a")
  wait("4s")
  -- Select Smash mode.
  press("a")
  wait("1s")
  -- Navigate to Squad Strike menu.
  press("down")
  press("left")
  press("a")
  wait("4s")
  -- Select first rule set.
  press("a")
  wait("4s")
  -- Select 3-on-3 mode.
  press("a")
  wait("2s")
  """,
  close_game: """
  -- Go to home screen.
  -- If on home screen, focus on running game.
  press("home")
  wait("700ms")
  -- Trigger game close.
  press("x")
  wait("700ms")
  -- Ackknowledge game close.
  press("a")
  wait("1s")
  """,
  load_squad_strike: """
  -- Press button to wake-up controller if needed.
  press("x")

  -- Load FP1
  load_amiibo_binary(amiibo1)
  move_pointer("pointer.png", {30, 125}, {65, 140})
  press("a")
  wait("200ms")
  press("a")
  wait("5s")

  -- Load FP2
  load_amiibo_binary(amiibo2)
  move_pointer("pointer.png", {30, 253}, {65, 270})
  press("a")
  wait("200ms")
  press("a")
  wait("5s")

  -- Load FP3
  load_amiibo_binary(amiibo3)
  move_pointer("pointer.png", {30, 385}, {65, 400})
  press("a")
  wait("200ms")
  press("a")
  wait("5s")

  -- Load FP4
  load_amiibo_binary(amiibo4)
  move_pointer("pointer.png", {595, 385}, {605, 400})
  press("a")
  wait("200ms")
  press("a")
  wait("5s")

  -- Load FP5
  load_amiibo_binary(amiibo5)
  move_pointer("pointer.png", {595, 253}, {615, 270})
  press("a")
  wait("200ms")
  press("a")
  wait("5s")

  -- Load FP6
  load_amiibo_binary(amiibo6)
  move_pointer("pointer.png", {595, 125}, {615, 140})
  press("a")
  wait("200ms")
  press("a")
  wait("5s")

  -- Move pointer out of the way to count the loaded FPs.
  press("up", "400ms")

  -- Take a screenshot to later check if any matchups loaded wrong.
  press("capture")

  -- Clear the amiibo to avoid problems later.
  clear_amiibo()
  """,
  squad_start: """
  -- Acknowledge character selection.
  press("plus")
  wait("5s")
  -- Randomize the squad.
  press("x")
  wait("5s")
  -- Start the match.
  press("a")
  wait("2s")
  """
}

for {name, script} <- scripts do
  payload = %{name: "#{name}.lua", bytes: script}
  cast.("script.put", payload)
end
```

Similarly, you can check that the scripts were uploaded.

```elixir
call.("script.list", %{})
```

```elixir
timeout = :timer.minutes(2)

call_with_opts.("script.run", %{name: "launch_ssbu_to_squad_strike.lua", timeout_ms: timeout},
  timeout_ms: timeout
)
```

```elixir
timeout = :timer.minutes(2)

# TODO: Set up the tournament.

amiibo_files = []

inputs =
  amiibo_files
  |> Enum.with_index(1)
  |> Map.new(fn {file, n} ->
    bytes = file |> File.read!() |> Base.encode64()
    data_url = "data:application/octet-stream;base64,#{bytes}"
    {"amiibo#{n}", data_url}
  end)

call_with_opts.(
  "script.run",
  %{name: "load_squad_strike.lua", timeout_ms: timeout, inputs: inputs},
  timeout_ms: timeout
)
```

<!-- livebook:{"offset":10817,"stamp":{"token":"QTEyOEdDTQ.1GkAdX6lPRkLjCJaX6Jk7Q-mdpspoY_ZM0MRHk1KebBrRKur_VCuABrPQw0.ciE2F25SuEfC_h5X.oRxKMrVdnV8eA1LQ0kucbiw2pu-HzAHp0KNT1istmR8lzGib0PxaFd_n_rw.4azRcVtDC9ioboJW13dyMw","version":1}} -->
