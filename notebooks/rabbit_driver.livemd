# Squad Strike Runner

```elixir
Mix.install([
  {:squad_strike, path: Path.join([__DIR__, "rabbit_driver", "squad_strike"])},
  {:jason, "~> 1.4"},
  {:amqp, "~> 3.3"},
  {:kino, "~> 0.10.0"}
])
```

## Setup RabbitMQ

**Before Running This Livbook!**

You first, need to open the Secrets tab in the sidebar to the left. In there you need to create
a secret named `AMQP_URL`. You will then put in the URL to connect to your RabbitMQ broker. It
will look like this:

```
amqp://username:password@raspberrypi.local:5672
```

If you enter it wrong, then you may see an error like this when running the setup cell.

```
01:12:17.379 [info] Application squad_strike exited: SquadStrike.Application.start(:normal, []) returned an error: shutdown: failed to start child: SquadStrike.MQ
    ** (EXIT) an exception was raised:
        ** (MatchError) no match of right hand side value: {:error, :econnrefused}
            (squad_strike 0.1.0) lib/squad_strike/mq.ex:22: anonymous fn/2 in SquadStrike.MQ.start_link/1
            (elixir 1.14.2) lib/agent/server.ex:8: Agent.Server.init/1
            (stdlib 4.0.1) gen_server.erl:848: :gen_server.init_it/2
            (stdlib 4.0.1) gen_server.erl:811: :gen_server.init_it/6
            (stdlib 4.0.1) proc_lib.erl:240: :proc_lib.init_p_do_apply/3
```

The default domain for a Raspberry Pi is `raspberrypi.local`. However, if you changed it, then
you will need to update the AMQP URL as well.

<blockquote style="background-color:#F5FF7B; color:black">
ðŸ’¡ This Livebook calls a helper project so you don't need to see all the code that's working in
the background. If you want to see it, you will find it at 
<code>notebooks/rabbit_driver/squad_strike</code>.
</blockquote>

The main modules used from the helper project are `SquadStrike` and `SquadStrike.MQ`. We'll alias the latter to just `MQ`.

You'll often see `MQ.cast` and `MQ.call`. `MQ.cast` sends a message but doesn't expect a reply. Similarly, `MQ.call` will send a message and wait for a response.

```elixir
alias SquadStrike.MQ, as: MQ
```

<!-- livebook:{"branch_parent_index":0} -->

## Logs

The app will send out logs, which you can watch. Once run, this will print logs to the must
recently run cell. Stopping this cell will stop the logs from appearing.

<blockquote style="background-color:#F5FF7B; color:black">
ðŸ’¡ This section runs in parallel with other code. That way you can watch the 
logs while running something else. You can skip over this section if you don't need it. 
</blockquote>

```elixir
require Logger

url = MQ.url()
exchange = MQ.exchange()

# Creating a new connection fixes some problems with stopping the cell.
{:ok, conn} = AMQP.Connection.open(url)
{:ok, channel} = AMQP.Channel.open(conn)
{:ok, %{queue: queue}} = AMQP.Queue.declare(channel, "", exclusive: true, auto_delete: true)

pid =
  spawn(fn ->
    AMQP.Queue.bind(channel, queue, exchange, routing_key: "log.#")
    {:ok, tag} = AMQP.Basic.consume(channel, queue, nil, no_ack: true)

    handler = fn recurse ->
      receive do
        {:basic_cancel, _meta} ->
          :ok

        {:basic_deliver, payload, _meta} ->
          %{"level" => level, "msg" => msg, "timestamp" => time} = Jason.decode!(payload)

          IO.puts("#{time} [#{level}] #{inspect(msg)}")

          recurse.(recurse)

        _ ->
          recurse.(recurse)
      after
        # When pings stop, automatically unsubscribe.
        2000 ->
          AMQP.Queue.unsubscribe(channel, tag)
          :ok
      end
    end

    handler.(handler)
  end)

heart_beat = fn recurse ->
  # Send the log watcher a ping to keep it alive.
  send(pid, :ping)

  # Wait a second so we aren't spamming the process.
  Process.sleep(1000)

  recurse.(recurse)
end

# Run the heartbeat function until the cell is explicitly stopped.
# Stopping the hearbeat messages will cause the queue to be cleaned up.
heart_beat.(heart_beat)
```

<!-- livebook:{"branch_parent_index":0} -->

## Screenshot

This section has some cells that are useful for debugging your capture card. Or you can use this
to get screenshots that you can then modify for use as targets in your automation.

<blockquote style="background-color:#F5FF7B; color:black">
ðŸ’¡ This section runs in parallel with other code. That way you can watch the 
continuous screen capture while running something else. You can skip over this section if you
don't need it. </blockquote>

First, is some basic code to handle requesting and handling the image. 
</blockquote>

```elixir
defmodule Screenshot do
  def capture(fun, opts \\ []) do
    {:ok, json, _meta} = MQ.call("image.screenshot", %{timeout_ms: 1000}, opts)

    bytes = Base.decode64!(json["screenshot"]["bytes"])

    fun.(bytes)
  rescue
    _error ->
      nil
  end

  def capture_forever(delay, fun) do
    # Create a queue so we don't make a new one with each request.
    {:ok, conn} = AMQP.Connection.open(MQ.url())
    {:ok, channel} = AMQP.Channel.open(conn)
    {:ok, %{queue: queue}} = AMQP.Queue.declare(channel, "", auto_delete: true)

    capture(fun, reply_to: queue)
    Process.sleep(delay)
    capture_forever(delay, fun)
  end
end
```

The next cell will capture a single image and display it. It's most useful for when grabbing an
image to use as an automation target. If the full image doesn't appear completely, then run the
cell again.

You will notice the screenshot appears squished. This is because the capture card is using a 
resolution of 640x480 which is a 4x3 ratio. The Switch normally runs a 16x9 ratio. This is 
expected and not a problem.

```elixir
image =
  Screenshot.capture(fn bytes ->
    bytes
  end)
```

This next cell will continuously capture images every few seconds. You can change the capture
rate. It's a number in milliseconds. Or you can use the `:timer.seconds` function. Be sure to 
click the <strong>Stop</strong> button when you are done watching.

```elixir
frame = Kino.Frame.new() |> Kino.render()

Screenshot.capture_forever(:timer.seconds(5), fn bytes ->
  Kino.Frame.render(frame, bytes)
end)
```

<!-- livebook:{"branch_parent_index":0} -->

## Squad Strike Automation

To run the automation, we first send some target images that we want to look for. They are 
usually small, unambiguous parts fo the screen.

![](img/ready_to_fight.png)

The scripts will reference these images. Typically checking if the image is visible, waiting until it becomes visible, or waiting until it disappears.

These images are dependent on the screen resolution of the capture card. If you don't use 
**640x480** as your resolution, then you must update all the images accordingly.

The scripts can also be sent ahead of time, or they can be run on demand. The following cell will send both the images and the scripts so they can be used by name.

```elixir
MQ.setup()
```

You can then check that the images were uploaded. Other images may also be present. You will
notice the Squad Strike images start with `ss_` to avoid name conflicts with other files.

```elixir
MQ.call("image.list", %{})
```

And the same for the scripts.

```elixir
MQ.call("script.list", %{})
```

```elixir
timeout = :timer.minutes(2)

MQ.call("script.run", %{name: "ss_launch_ssbu.lua", timeout_ms: timeout}, timeout_ms: timeout)
```

<!-- livebook:{"offset":7242,"stamp":{"token":"QTEyOEdDTQ._Q9fW2xut98I6kFkyhV6SvSo0Ym-sW5g-kLamofpNFqwXZOzV8dcCQAzdZc.BaksiRunP7oESZ-B.rSkRyEKfm0fLhnx55Vfnpx9nc0CckD5L1diTBdCEVpOufvqnlFD5pbthbxY.xYc4Ob-RiP_UIaOhPo3YeA","version":1}} -->
